---
title: Parallel MCMC
output: html_document
---

<!---
http://danielturek.github.io/public/parallelMCMC/parallelMCMC
-->

Back to [NIMBLE Vignettes](https://danielturek.github.io/public/nimble_vignettes.html)

\    

The following demonstrates how to execute `nc` chains of an MCMC using
the `parallel` package, then assess convergence; then, to continue
running each of the `nc` chains in parallel to extend the MCMC run.

\   


```{r, eval = FALSE}
library(nimble)
library(parallel)
library(basicMCMCplots)

code <- nimbleCode({ a ~ dnorm(0, 1) })
constants <- list()
data <- list()
initsFunction <- function() { list(a = rnorm(1)) }
    
nc <- 3   ## number of chains
cl <- makeCluster(nc, timeout = 5184000)
clusterExport(cl, c('code', 'constants', 'data'))

for(i in seq_along(cl)) {
    set.seed(i)
    inits <- initsFunction()
    clusterExport(cl[i], c('inits', 'i'))
}

samplesList1 <- clusterEvalQ(cl, {
    library(nimble)
    Rmodel <- nimbleModel(code, constants, data, inits)
    conf <- configureMCMC(Rmodel)
    Rmcmc <- buildMCMC(conf)
    Cmodel <- compileNimble(Rmodel)
    Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
    set.seed(i)
    samples <- runMCMC(Cmcmc, 10000)
    return(samples)
})

names(samplesList1) <- paste0('chain', 1:nc)

## assess convergence of samplesList1,
## if not converged, then continue sampling:
chainsPlot(samplesList1)

samplesList2 <- clusterEvalQ(cl, {
    Cmcmc$run(10000, reset = FALSE)
    samples <- as.matrix(Cmcmc$mvSamples)
    return(samples)
})

names(samplesList2) <- paste0('chain', 1:nc)
```


\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

