---
title: 'Sampler Performance'
author: Daniel Turek
publish: true
---

Investigating the performance hit from having additional boolean conditional evaluations in MCMC samplers.

### Define a new RW sampler

This sampler is *identical* to the standard RW sampler, except I'll add three -- you read that right -- *three* additional if(condition) evaluations to the run() function.

```{r, message = FALSE}
library(nimble)

sampler_RW_slow <- nimbleFunction(
    contains = sampler_BASE,
    setup = function(model, mvSaved, target, control) {
        ###  control list extraction  ###
        adaptive      <- control$adaptive
        adaptInterval <- control$adaptInterval
        scale         <- control$scale
        ###  node list generation  ###
        targetAsScalar <- model$expandNodeNames(target, returnScalarComponents = TRUE)
        if(length(targetAsScalar) > 1)     stop('more than one target; cannot use RW sampler, try RW_block sampler')
        calcNodes  <- model$getDependencies(target)
        ###  numeric value generation  ###
        scaleOriginal <- scale
        timesRan      <- 0
        timesAccepted <- 0
        timesAdapted  <- 0
        scaleHistory          <- c(0, 0)
        acceptanceRateHistory <- c(0, 0)
        ## variables previously inside of nested functions:
        optimalAR <- 0.44
        gamma1    <- 0
        ## new variable:
        logicalVariable <- FALSE
    },
    run = function() {
        if(logicalVariable)    { print('should never get here') }
        if(logicalVariable)    { print('should never get here') }
        if(logicalVariable)    { print('should never get here') }
        propValue <- rnorm(1, mean = model[[target]], sd = scale)
     	model[[target]] <<- propValue
        logMHR <- calculateDiff(model, calcNodes)
        jump <- decide(logMHR)
        if(jump)
            nimCopy(from = model, to = mvSaved, row = 1, nodes = calcNodes, logProb = TRUE)
        else
            nimCopy(from = mvSaved, to = model, row = 1, nodes = calcNodes, logProb = TRUE)
        if(adaptive)     adaptiveProcedure(jump)
    },
    methods = list(
        adaptiveProcedure = function(jump = logical()) {
            timesRan <<- timesRan + 1
            if(jump)     timesAccepted <<- timesAccepted + 1
            if(timesRan %% adaptInterval == 0) {
                acceptanceRate <- timesAccepted / timesRan
                timesAdapted <<- timesAdapted + 1
                setSize(scaleHistory,          timesAdapted)
                setSize(acceptanceRateHistory, timesAdapted)
                scaleHistory[timesAdapted] <<- scale
                acceptanceRateHistory[timesAdapted] <<- acceptanceRate
                gamma1 <<- 1/((timesAdapted + 3)^0.8)
                gamma2 <- 10 * gamma1
                adaptFactor <- exp(gamma2 * (acceptanceRate - optimalAR))
                scale <<- scale * adaptFactor
                timesRan <<- 0
                timesAccepted <<- 0
            }
        },
        reset = function() {
            scale <<- scaleOriginal
            timesRan      <<- 0
            timesAccepted <<- 0
            timesAdapted  <<- 0
            scaleHistory          <<- scaleHistory          * 0
            acceptanceRateHistory <<- acceptanceRateHistory * 0
            gamma1 <<- 0
        }
    ), where = getLoadingNamespace()
)
```

### Define our model

```{r}
code <- nimbleCode({
    for(i in 1:100) {
        a[i] ~ dnorm(0, 1)
    }
})
constants <- list()
data <- list()
inits <- list(a = rep(0,100))

Rmodel <- nimbleModel(code, constants, data, inits)
Cmodel <- compileNimble(Rmodel)
```

### MCMC with standard RW sampler

```{r}
spec <- configureMCMC(Rmodel, nodes = NULL)

for(node in paste0('a[', 1:100, ']'))
    spec$addSampler(type = 'RW', target = node, print = FALSE)

spec$printSamplers()

Rmcmc <- buildMCMC(spec)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
```


### MCMC with RW_slow sampler

```{r}
spec_slow <- configureMCMC(Rmodel, nodes = NULL)

for(node in paste0('a[', 1:100, ']'))
    spec_slow$addSampler(type = 'RW_slow', target = node, print = FALSE)

spec_slow$printSamplers()

Rmcmc_slow <- buildMCMC(spec_slow)
Cmcmc_slow <- compileNimble(Rmcmc_slow, project = Rmodel, resetFunctions = TRUE)
```

### Let's compare these results

What you've all been waiting for

```{r}
## 1 million MCMC iterations
niter <- 1000000

## Note that whatever performance difference we see
## is resulting from three additional if() evaulations,
## on 100 model nodes, for 1 million iterations...

system.time(Cmcmc$run(niter))

system.time(Cmcmc_slow$run(niter))
```

